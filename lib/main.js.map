{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "AAEA;EAAA;AAAA,MAAA,CAAA,EAAA,GAAA,EAAA,MAAA,EAAA,KAAA,EAAA,YAAA,EAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd;;EAC5B,CAAA,CAAE,EAAF,EACE,MADF,CAAA,GAC4B,GAD5B;;EAEA,CAAA,CAAE,IAAF,EACE,MADF,CAAA,GAC4B,OAAA,CAAQ,gBAAR,CAD5B,EAhBA;;;;;EAuBA,CAAA,GAAI,MAAA,CACF;IAAA,cAAA,EAAkB,UAAY,0EAA9B;IACA,SAAA,EAAkB,CAAY,0EAD9B;IAEA,UAAA,EAAkB,CAAC,UAAW,0EAF9B;IAGA,UAAA,EAAkB,CAAC,UAAW,0EAH9B;;IAKA,OAAA,EAAkB,CAAY,0EAL9B;IAMA,QAAA,EAAkB,EAAY,0EAN9B;IAOA,QAAA,EAAkB,GAAY,0EAP9B;IAQA,SAAA,EAAkB,GAAY,0EAR9B;IASA,UAAA,EAAkB,GAAY,0EAT9B;IAUA,UAAA,EAAkB,QAAA,CAAS,OAAT,EAAkB,EAAlB,CAVlB;IAWA,UAAA,EAAkB,QAAA,CAAS,OAAT,EAAkB,EAAlB,CAXlB;;IAaA,QAAA,EACE;MAAA,mBAAA,EACE;QAAA,SAAA,EAAc,CAAY,oCAA1B;QACA,QAAA,EAAc,KADd;;QAGA,MAAA,EAAc;MAHd;IADF;EAdF,CADE,EAvBJ;;;;;EA+CA,YAAA,GAAe,QAAA,CAAE,QAAF,CAAA;AACf,QAAA;IAAE,KAAA,GAAQ,IAAI,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,SAA5B,CAAA,EAAV;;IAGE,KAAK,CAAC,OAAN,CAAc,qBAAd,EAAqC;MAAA,KAAA,EACnC;QAAA,eAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;iBAAS,IAAC,CAAA,GAAG,CAAC,MAAL,CAAY,CAAZ;QAAT,CAApC;QACA,2BAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;iBAAS,IAAC,CAAA,GAAG,CAAC,QAAL,CAAc,CAAC,CAAC,SAAhB;QAAT,CADpC;QAEA,yBAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;iBAAS,IAAC,CAAA,GAAG,CAAC,OAAL,CAAa,CAAC,CAAC,QAAf;QAAT,CAFpC;QAGA,+BAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;AAAQ,cAAA;wBAAC,CAAC,CAAC,YAAY,SAAd,QAAqB;QAA9B;MAHpC;IADmC,CAArC;IAKA,KAAK,CAAC,QAAQ,CAAC,mBAAf,CAAmC,QAAQ,CAAC,GAA5C,EARF;;IAWE,KAAK,CAAC,OAAN,CAAc,SAAd,EAAyB,QAAA,CAAE,CAAF,CAAA;MAEvB,KAAoB,IAAC,CAAA,GAAG,CAAC,aAAL,CAAmB,CAAnB,CAApB;;AAAA,eAAO,MAAP;;AACA,aAAO,CAAC,CAAC,KAAF,CAAQ,CAAE,EAAF,CAAA,GAAA;eAAU,IAAC,CAAA,GAAG,CAAC,gBAAL,CAAsB,EAAtB;MAAV,CAAR;IAHgB,CAAzB,EAXF;;AAiBE,WAAO;EAlBM,EA/Cf;;;;;;EAuEM,IAAC,CAAA;IAAP,MAAA,UAAA,CAAA;;MAME,WAAa,CAAE,GAAF,CAAA,EAAA;;;;YAab,CAAA,kBAAA,CAAA,uBAZF;;YA6BE,CAAA,kBAAA,CAAA,uBA7BF;;;;YA4CE,CAAA,aAAA,CAAA,kBA5CF;;YAkDE,CAAA,aAAA,CAAA,kBAlDF;;YA0DE,CAAA,cAAA,CAAA;YACA,CAAA,aAAA,CAAA,kBA3DF;;YA8DE,CAAA,WAAA,CAAA,gBA9DF;;;;;YA8EE,CAAA,yBAAA,CAAA,8BA9EF;;YAoFE,CAAA,iCAAA,CAAA,sCApFF;;YA8FE,CAAA,gBAAA,CAAA,qBA9FF;;;;;;;;;;;;;;;;;;;;;;;;YAuHE,CAAA,UAAA,CAAA,eAvHF;;YAmIE,CAAA,iBAAA,CAAA,sBAnIF;;YA0IE,CAAA,WAAA,CAAA;QA1IE,IAAC,CAAA,GAAD,GAAU,CAAE,GAAA,CAAC,CAAC,QAAQ,CAAC,mBAAb,EAAqC,GAAA,GAArC;QACV,IAAC,CAAA,KAAD,GAAU,YAAA,CAAa,IAAb;QACV,IAAC,CAAA,GAAD,GAAU,MAAA,CAAO,IAAC,CAAA,GAAR;QACV,IAAC,CAAA,MAAD;AAAU,kBAAO,IAAC,CAAA,GAAG,CAAC,MAAZ;AAAA,iBACH,KADG;qBACQ,IAAC,CAAA;AADT,iBAEH,KAFG;qBAEQ,IAAC,CAAA;AAFT;;AAGV,eAAO;MAPI;;MAab,WAAa,CAAE,GAAF,CAAA;AACf,YAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,EAAA,EAAA,MAM8D,gCAN9D,EAAA,GAAA,EAAA,IAAA,EAAA;QAGI,IAA2B,IAAC,CAAA,GAAG,CAAC,QAAhC;;;;UAAA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,GAApB,EAAA;;QACA,MAAO,CAAA,CAAA,UAAI,GAAG,CAAC,OAAR,OAAA,IAAkB,IAAC,CAAA,GAAG,CAAC,SAAvB,EAAP;UACE,MAAM,IAAI,KAAJ,CAAU,CAAA,yCAAA,CAAA,CAA4C,IAAC,CAAA,GAAG,CAAC,SAAjD,CAAA,2BAAA,CAAA,CAAwF,GAAG,CAAC,MAA5F,CAAA,CAAV,EADR;;QAEA,CAAA,GAAU,MAAM,CAAC,KAAP,CAAa,IAAC,CAAA,GAAG,CAAC,SAAL,GAAiB,CAAC,CAAC,SAAhC,EAA2C,IAA3C;QACV,MAAA,GAAU,CAAC,CAAC,CAAC;QACb,KAAW,sGAAX;UACE,EAAA,sCAAkB;UAClB,EAAA,GAAK,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,IAAC,CAAA,WAAW,CAAC,CAAC,CAAC,UAA5B;UACL,EAAA,GAAK,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,IAAC,CAAA,WAAW,CAAC,CAAC,CAAC,UAA5B;UACL,CAAC,CAAC,aAAF,CAAgB,EAAA,GAAK,CAAC,CAAC,cAAvB,EAAuC,CAAE,MAAA,IAAU,CAAC,CAAC,SAAd,CAAvC;QAJF;AAKA,eAAO;MAdI;;MAiBb,WAAa,CAAE,GAAF,CAAA;AACf,YAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA;QAAI,IAA2B,IAAC,CAAA,GAAG,CAAC,QAAhC;UAAA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,GAApB,EAAA;;QACA,CAAA,GAAI;QACJ,KAAW,iGAAX;UACE,EAAA,sCAAqB;UACrB,IAAA,GAAW,EAAA,IAAM,CAAT,GAAgB,CAAC,CAAC,QAAlB,GAAgC,CAAC,CAAC;UAC1C,EAAA,GAAQ,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,IAAC,CAAA,WAAW,CAAC,CAAC,CAAC,UAA5B;UACR,EAAA,GAAQ,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,IAAC,CAAA,WAAW,CAAC,CAAC,CAAC,UAA5B;UACR,CAAC,CAAC,IAAF,CAAO,IAAA,GAAO,CAAE,CAAE,IAAI,CAAC,GAAL,CAAS,EAAT,CAAF,CAAe,CAAC,QAAhB,CAAyB,CAAC,CAAC,QAA3B,CAAF,CAAuC,CAAC,QAAxC,CAAiD,CAAC,CAAC,OAAnD,EAA4D,CAAC,CAAC,UAA9D,CAAd;QALF;AAMA,eAAO,CAAC,CAAC,IAAF,CAAO,GAAP;MATI;;MAeb,MAAQ,CAAE,SAAS,IAAX,CAAA;QACN,IAAqB,cAArB;AAAA,iBAAO,CAAE,CAAF,EAAP;;QACA,IAA8B,IAAC,CAAA,GAAG,CAAC,QAAnC;UAAA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,MAApB,EAAA;;AACA,eAAO,CAAE,GAAA,MAAF;MAHD;;MAMR,MAAQ,CAAE,GAAF,EAAO,KAAK,CAAZ,CAAA;QAIN,IAA2B,IAAC,CAAA,GAAG,CAAC,QAAhC;;;;UAAA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,GAApB,EAAA;;AACA,eAAO,CAAE,GAAA,GAAF,EAAU,EAAV;MALD;;MAQR,OAAU,CAAE,GAAF,CAAA;eAAW,IAAC,CAAA,IAAD,CAAM,GAAN,EAAW,CAAC,CAAZ;MAAX;;MACV,MAAU,CAAE,GAAF,CAAA;eAAW,IAAC,CAAA,IAAD,CAAM,GAAN,EAAW,CAAC,CAAZ;MAAX;;MAGV,IAAM,CAAE,GAAF,EAAO,KAAP,CAAA;AACR,YAAA,CAAA;;;;QAGI,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,GAApB;UACA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,OAAhB,CAAwB,KAAxB,EAFF;;QAGA,CAAA,GAAsB,CAAE,GAAA,GAAF;QACtB,CAAC,CAAE,GAAG,CAAC,MAAJ,GAAa,CAAf,CAAD,IAAwB;AACxB,eAAO;MATH;;MAgBN,kBAAoB,CAAE,IAAF,EAAQ,SAAR,CAAA;AACtB,YAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA;QAAI,KAAW,iHAAX;UACE,IAAiB,IAAI,CAAE,GAAF,CAAJ,KAAiB,CAAlC;AAAA,mBAAO,MAAP;;QADF;AAEA,eAAO;MAHW;;MAMpB,0BAA4B,CAAE,IAAF,EAAQ,SAAR,CAAA;AAC9B,YAAA,CAAA,EAAA;QAAI,GAAA,GAAM;AACN,eAAA,IAAA;UACE,IAAG,CAAE,CAAA,GAAI,IAAI,CAAE,GAAF,CAAV,CAAA,KAAuB,CAA1B;YACE,GAAA;AACA,qBAFF;;UAGA,IAAgB,CAAE,CAAA,KAAK,MAAP,CAAA,IAAsB,CAAE,CAAA,GAAI,CAAN,CAAtC;AAAA,mBAAO,MAAP;;AACA,iBAAO;QALT;MAF0B;;MAU5B,SAAW,CAAE,CAAF,EAAK,CAAL,CAAA;eAAY,CAAC,CAAC,OAAF,CAAU,CAAV;MAAZ;;MAyBX,GAAK,CAAE,CAAF,EAAK,CAAL,CAAA;AACP,YAAA,EAAA,EAAA,EAAA,EAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA;QAAI,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,CAApB;UACA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,CAApB,EAFF;;QAGA,KAAW,2GAAX;UACE,EAAA,oCAAgB;UAChB,EAAA,oCAAgB;UAChB,IAAa,EAAA,GAAK,EAAlB;AAAA,mBAAO,CAAC,EAAR;;UACA,IAAa,EAAA,GAAK,EAAlB;AAAA,mBAAO,CAAC,EAAR;;QAJF;AAKA,eAAO;MATJ;;MAYL,UAAY,CAAE,SAAF,CAAA,EAAA;;QAEV,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,IAAhB,CAAqB,SAArB,EADF;;AAEA,eAAO,CAAE,GAAA,SAAF,CAAiB,CAAC,IAAlB,CAAuB,CAAE,CAAF,EAAK,CAAL,CAAA,GAAA;iBAAY,CAAC,CAAC,OAAF,CAAU,CAAV;QAAZ,CAAvB;MAJG;;MAOZ,IAAM,CAAE,IAAF,CAAA,EAAA;;QAEJ,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,IAAhB,CAAqB,IAArB,EADF;;AAEA,eAAO,CAAE,GAAA,IAAF,CAAY,CAAC,IAAb,CAAkB,IAAC,CAAA,GAAnB;MAJH;;IAjJR;;;IAGE,SAAC,CAAA,CAAD,GAAI;;;;gBA1EN;;;EAgOA,IAAC,CAAA,SAAD,GAAc,MAAA,CAAO,IAAC,CAAA,SAAR;;EACd,IAAC,CAAA,SAAD,GAAc,IAAI,IAAC,CAAA,SAAL,CAAA;AAjOd",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'HOLLERITH'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n{ jr\n  assign }                = CND\n{ lets\n  freeze }                = require 'letsfreezethat'\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nC = freeze\n  u32_sign_delta:   0x80000000  ### used to lift negative numbers to non-negative                        ###\n  u32_width:        4           ### bytes per element                                                    ###\n  u32_nr_min:       -0x80000000 ### smallest possible VNR element                                        ###\n  u32_nr_max:       +0x7fffffff ### largest possible VNR element                                         ###\n  #.........................................................................................................\n  bcd_dpe:          4           ### digits per element                                                   ###\n  bcd_base:         36          ### number base                                                          ###\n  bcd_plus:         '+'         ### plus symbol, should sort after bcd_minus                             ###\n  bcd_minus:        '!'         ### minus symbol, should sort before bcd_plus                            ###\n  bcd_padder:       '.'         ### used to pad empty fields                                             ###\n  bcd_nr_max:       parseInt '+zzzz', 36\n  bcd_nr_min:       parseInt '-zzzz', 36\n  #.........................................................................................................\n  defaults:\n    hlr_constructor_cfg:\n      vnr_width:    5           ### maximum elements in VNR vector ###\n      validate:     false\n      # autoextend: false\n      format:       'u32'\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\ncreate_types = ( instance ) ->\n  types = new ( require 'intertype' ).Intertype()\n\n  #-----------------------------------------------------------------------------------------------------------\n  types.declare 'hlr_constructor_cfg', tests:\n    \"x is a object\":                    ( x ) -> @isa.object x\n    \"@isa.cardinal x.vnr_width\":        ( x ) -> @isa.cardinal x.vnr_width\n    \"@isa.boolean x.validate\":          ( x ) -> @isa.boolean x.validate\n    \"x.format in [ 'u32', 'bcd', ]\":    ( x ) -> x.format in [ 'u32', 'bcd', ]\n  types.validate.hlr_constructor_cfg instance.cfg\n\n  #-----------------------------------------------------------------------------------------------------------\n  types.declare 'hlr_vnr', ( x ) ->\n    ### TAINT check bounds of elements ###\n    return false unless @isa.nonempty_list x\n    return x.every ( xx ) => @isa.positive_integer xx\n\n  #-----------------------------------------------------------------------------------------------------------\n  return types\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n### TAINT use separate class? for validation to eschew extra call on each use ###\nclass @Hollerith\n\n  #---------------------------------------------------------------------------------------------------------\n  @C: C\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @cfg    = { C.defaults.hlr_constructor_cfg..., cfg..., }\n    @types  = create_types @\n    @cfg    = freeze @cfg\n    @encode = switch @cfg.format\n      when 'u32' then @_encode_u32\n      when 'bcd' then @_encode_bcd\n    return undefined\n\n\n  #=========================================================================================================\n  #\n  #---------------------------------------------------------------------------------------------------------\n  _encode_u32: ( vnr ) =>\n    ### Observe that we limit all VNR elements to `[ u32_nr_max .. u32_nr_min ]` so numbers outside that\n    range will no longer cause an error. Clients will have to check for boundaries somewhere else if they\n    so wish. ###\n    @types.validate.vnr vnr if @cfg.validate\n    unless 0 < vnr.length <= @cfg.vnr_width\n      throw new Error \"^44798^ expected VNR to be between 1 and #{@cfg.vnr_width} elements long, got length #{vnr.length}\"\n    R       = Buffer.alloc @cfg.vnr_width * C.u32_width, 0x00 ### TAINT pre-compute constant ###\n    offset  = -C.u32_width\n    for idx in [ 0 ... @cfg.vnr_width ]\n      nr = vnr[ idx ] ? 0\n      nr = Math.min nr, @constructor.C.u32_nr_max\n      nr = Math.max nr, @constructor.C.u32_nr_min\n      R.writeUInt32BE nr + C.u32_sign_delta, ( offset += C.u32_width )\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _encode_bcd: ( vnr ) =>\n    @types.validate.vnr vnr if @cfg.validate\n    R = []\n    for idx in [ 0 ... @cfg.vnr_width ]\n      nr    = vnr[ idx ] ? 0\n      sign  = if nr >= 0 then C.bcd_plus else C.bcd_minus\n      nr    = Math.min nr, @constructor.C.bcd_nr_max\n      nr    = Math.max nr, @constructor.C.bcd_nr_min\n      R.push sign + ( ( Math.abs nr ).toString C.bcd_base ).padStart C.bcd_dpe, C.bcd_padder\n    return R.join ','\n\n\n  #=========================================================================================================\n  #\n  #---------------------------------------------------------------------------------------------------------\n  create: ( source = null ) =>\n    return [ 0, ] unless source?\n    @types.validate.vnr source if @cfg.validate\n    return [ source..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  deepen: ( vnr, nr = 0 ) =>\n    ### Given a vectorial line number `vnr`, return a copy of `vnr`, call it\n    `vnr0`, which has an index of `0` appended, thus representing the pre-first `vnr` for a level of lines\n    derived from the one that the original `vnr` pointed to. ###\n    @types.validate.vnr vnr if @cfg.validate\n    return [ vnr..., nr, ]\n\n  #---------------------------------------------------------------------------------------------------------\n  advance:  ( vnr ) => @move vnr, +1\n  recede:   ( vnr ) => @move vnr, -1\n\n  #---------------------------------------------------------------------------------------------------------\n  move: ( vnr, delta ) =>\n    ### Given a vectorial line number `vnr`, return a copy of `vnr`, call it\n    `vnr0`, which has its last index incremented by `1`, thus representing the vectorial line number of the\n    next line in the same level that is derived from the same line as its predecessor. ###\n    if @cfg.validate\n      @types.validate.vnr vnr\n      @types.validate.integer delta\n    R                   = [ vnr..., ]\n    R[ vnr.length - 1 ]  += delta\n    return R\n\n\n  #=========================================================================================================\n  # SORTING\n  #---------------------------------------------------------------------------------------------------------\n  ### TAINT conflate _only_zeroes_after(), _first_nonzero_is_negative() ###\n  _only_zeroes_after: ( list, first_idx ) =>\n    for idx in [ first_idx ... list.length ]\n      return false  if list[ idx ] isnt 0\n    return true\n\n  #---------------------------------------------------------------------------------------------------------\n  _first_nonzero_is_negative: ( list, first_idx ) =>\n    idx = first_idx\n    loop\n      if ( R = list[ idx ] ) is 0\n        idx++\n        continue\n      return false if ( R is undefined ) or ( R > 0 )\n      return true\n\n  #---------------------------------------------------------------------------------------------------------\n  cmp_blobs: ( a, b ) => a.compare b\n\n  # #---------------------------------------------------------------------------------------------------------\n  # cmp: ( a, b ) =>\n  #   if @cfg.validate\n  #     @types.validate.vnr a\n  #     @types.validate.vnr b\n  #   a_length  = a.length\n  #   b_length  = b.length\n  #   min_idx   = ( Math.min a_length, b_length ) - 1\n  #   for idx in [ 0 .. min_idx ]\n  #     ai = a[ idx ]\n  #     bi = b[ idx ]\n  #     return -1 if ai < bi\n  #     return +1 if ai > bi\n  #   return  0 if a_length is b_length\n  #   if a_length < b_length\n  #     return 0  if @_only_zeroes_after          b, min_idx + 1\n  #     return +1 if @_first_nonzero_is_negative  b, min_idx + 1\n  #     return -1\n  #   return 0  if @_only_zeroes_after          a, min_idx + 1\n  #   return -1 if @_first_nonzero_is_negative  a, min_idx + 1\n  #   return +1\n\n  #---------------------------------------------------------------------------------------------------------\n  cmp: ( a, b ) =>\n    if @cfg.validate\n      @types.validate.vnr a\n      @types.validate.vnr b\n    for idx in [ 0 ... ( Math.max a.length, b.length ) ]\n      ai = a[ idx ] ? 0\n      bi = b[ idx ] ? 0\n      return -1 if ai < bi\n      return +1 if ai > bi\n    return 0\n\n  #---------------------------------------------------------------------------------------------------------\n  sort_blobs: ( vnr_blobs ) =>\n    ### Given a list of VNRs, return a copy of the list with the VNRs lexicographically sorted. ###\n    if @cfg.validate\n      @types.validate.list vnr_blobs\n    return [ vnr_blobs..., ].sort ( a, b ) => a.compare b\n\n  #---------------------------------------------------------------------------------------------------------\n  sort: ( vnrs ) =>\n    ### Given a list of VNRs, return a copy of the list with the VNRs lexicographically sorted. ###\n    if @cfg.validate\n      @types.validate.list vnrs\n    return [ vnrs..., ].sort @cmp\n\n\n#===========================================================================================================\n@Hollerith  = freeze @Hollerith\n@HOLLERITH  = new @Hollerith()\n\n\n"
  ]
}