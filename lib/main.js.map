{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "AAEA;EAAA;AAAA,MAAA,CAAA,EAAA,GAAA,EAAA,MAAA,EAAA,KAAA,EAAA,YAAA,EAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd;;EAC5B,CAAA,CAAE,EAAF,EACE,MADF,CAAA,GAC4B,GAD5B;;EAEA,CAAA,CAAE,IAAF,EACE,MADF,CAAA,GAC4B,OAAA,CAAQ,gBAAR,CAD5B,EAhBA;;;;;EAuBA,CAAA,GAAI,MAAA,CACF;IAAA,UAAA,EAAc,UAAY,mDAA1B;IACA,SAAA,EAAc,CAAY,uBAD1B;IAEA,MAAA,EAAc,CAAC,UAAW,mCAF1B;IAGA,MAAA,EAAc,CAAC,UAAW,kCAH1B;;IAKA,QAAA,EACE;MAAA,mBAAA,EACE;QAAA,SAAA,EAAc,CAAY,oCAA1B;QACA,QAAA,EAAc;MADd;IADF;EANF,CADE,EAvBJ;;;;;;;EAuCA,YAAA,GAAe,QAAA,CAAE,QAAF,CAAA;AACf,QAAA;IAAE,KAAA,GAAQ,IAAI,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,SAA5B,CAAA,EAAV;;IAGE,KAAK,CAAC,OAAN,CAAc,qBAAd,EAAqC;MAAA,KAAA,EACnC;QAAA,eAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;iBAAS,IAAC,CAAA,GAAG,CAAC,MAAL,CAAY,CAAZ;QAAT,CAApC;QACA,2BAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;iBAAS,IAAC,CAAA,GAAG,CAAC,QAAL,CAAc,CAAC,CAAC,SAAhB;QAAT,CADpC;QAEA,yBAAA,EAAoC,QAAA,CAAE,CAAF,CAAA;iBAAS,IAAC,CAAA,GAAG,CAAC,OAAL,CAAa,CAAC,CAAC,QAAf;QAAT;MAFpC;IADmC,CAArC;IAIA,KAAK,CAAC,QAAQ,CAAC,mBAAf,CAAmC,QAAQ,CAAC,GAA5C,EAPF;;IAUE,KAAK,CAAC,OAAN,CAAc,SAAd,EAAyB,QAAA,CAAE,CAAF,CAAA;MAEvB,KAAoB,IAAC,CAAA,GAAG,CAAC,aAAL,CAAmB,CAAnB,CAApB;;AAAA,eAAO,MAAP;;AACA,aAAO,CAAC,CAAC,KAAF,CAAQ,CAAE,EAAF,CAAA,GAAA;eAAU,IAAC,CAAA,GAAG,CAAC,gBAAL,CAAsB,EAAtB;MAAV,CAAR;IAHgB,CAAzB,EAVF;;AAgBE,WAAO;EAjBM,EAvCf;;;;;;EA8DM,IAAC,CAAA;IAAP,MAAA,UAAA,CAAA;;MAME,WAAa,CAAE,GAAF,CAAA,EAAA;;YA+Bb,CAAA,aAAA,CAAA,kBA9BF;;YAoCE,CAAA,aAAA,CAAA,kBApCF;;YA4CE,CAAA,cAAA,CAAA;YACA,CAAA,aAAA,CAAA,kBA7CF;;YAgDE,CAAA,WAAA,CAAA,gBAhDF;;YA4DE,CAAA,iCAAA,CAAA,sCA5DF;;YAsEE,CAAA,UAAA,CAAA,eAtEF;;YA0FE,CAAA,WAAA,CAAA;QA1FE,IAAC,CAAA,GAAD,GAAU,CAAE,GAAA,CAAC,CAAC,QAAQ,CAAC,mBAAb,EAAqC,GAAA,GAArC;QACV,IAAC,CAAA,KAAD,GAAU,YAAA,CAAa,IAAb;QACV,IAAC,CAAA,GAAD,GAAU,MAAA,CAAO,IAAC,CAAA,GAAR;AACV,eAAO;MAJI,CAJf;;;MAWE,MAAQ,CAAE,GAAF,CAAA;AACV,YAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,MAE8D,gCAF9D,EAAA,GAAA,EAAA,IAAA,EAAA;QAAI,MAAO,CAAA,CAAA,UAAI,GAAG,CAAC,OAAR,OAAA,IAAkB,IAAC,CAAA,GAAG,CAAC,SAAvB,EAAP;UACE,MAAM,IAAI,KAAJ,CAAU,CAAA,yCAAA,CAAA,CAA4C,IAAC,CAAA,GAAG,CAAC,SAAjD,CAAA,2BAAA,CAAA,CAAwF,GAAG,CAAC,MAA5F,CAAA,CAAV,EADR;;QAEA,CAAA,GAAU,MAAM,CAAC,KAAP,CAAa,IAAC,CAAA,GAAG,CAAC,SAAL,GAAiB,CAAC,CAAC,SAAhC,EAA2C,IAA3C;QACV,MAAA,GAAU,CAAC,CAAC,CAAC;QACb,KAAW,sGAAX;UACE,CAAC,CAAC,aAAF,CAAgB,oCAAe,CAAf,CAAA,GAAqB,CAAC,CAAC,UAAvC,EAAmD,CAAE,MAAA,IAAU,CAAC,CAAC,SAAd,CAAnD;QADF;AAEA,eAAO;MAPD,CAXV;;;MAqBE,WAAa,CAAE,GAAF,CAAA;AACf,YAAA,CAAA,EAAA,IAAA,EAAA,GAAA,EAAA,CAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,MAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA;QAAI,GAAA,GAAc,CAAY;QAC1B,IAAA,GAAc;QACd,IAAA,GAAc;QACd,KAAA,GAAc;QACd,MAAA,GAAc;QACd,CAAA,GAAc;QACd,KAAW,iGAAX;UACE,EAAA,sCAAqB;UACrB,IAAA,GAAW,EAAA,IAAM,CAAT,GAAgB,IAAhB,GAA0B;UAClC,CAAC,CAAC,IAAF,CAAO,IAAA,GAAO,CAAE,CAAE,IAAI,CAAC,GAAL,CAAS,EAAT,CAAF,CAAe,CAAC,QAAhB,CAAyB,IAAzB,CAAF,CAAiC,CAAC,QAAlC,CAA2C,GAA3C,EAAgD,MAAhD,CAAd;QAHF;AAIA,eAAO,CAAC,CAAC,IAAF,CAAO,GAAP;MAXI;;MAcb,MAAQ,CAAE,SAAS,IAAX,CAAA;QACN,IAAqB,cAArB;AAAA,iBAAO,CAAE,CAAF,EAAP;;QACA,IAA8B,IAAC,CAAA,GAAG,CAAC,QAAnC;UAAA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,MAApB,EAAA;;AACA,eAAO,CAAE,GAAA,MAAF;MAHD;;MAMR,MAAQ,CAAE,CAAF,EAAK,KAAK,CAAV,CAAA;QAIN,IAAyB,IAAC,CAAA,GAAG,CAAC,QAA9B;;;;UAAA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,CAApB,EAAA;;AACA,eAAO,CAAE,GAAA,CAAF,EAAQ,EAAR;MALD;;MAQR,OAAU,CAAE,CAAF,CAAA;eAAS,IAAC,CAAA,IAAD,CAAM,CAAN,EAAS,CAAC,CAAV;MAAT;;MACV,MAAU,CAAE,CAAF,CAAA;eAAS,IAAC,CAAA,IAAD,CAAM,CAAN,EAAS,CAAC,CAAV;MAAT;;MAGV,IAAM,CAAE,CAAF,EAAK,KAAL,CAAA;AACR,YAAA,CAAA;;;;QAGI,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,CAApB;UACA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,OAAhB,CAAwB,KAAxB,EAFF;;QAGA,CAAA,GAAsB,CAAE,GAAA,CAAF;QACtB,CAAC,CAAE,CAAC,CAAC,MAAF,GAAW,CAAb,CAAD,IAAsB;AACtB,eAAO;MATH;;MAYN,0BAA4B,CAAE,IAAF,EAAQ,SAAR,CAAA;AAC9B,YAAA,CAAA,EAAA;QAAI,GAAA,GAAM;AACN,eAAA,IAAA;UACE,IAAG,CAAE,CAAA,GAAI,IAAI,CAAE,GAAF,CAAV,CAAA,KAAuB,CAA1B;YACE,GAAA;AACA,qBAFF;;UAGA,IAAgB,CAAE,CAAA,KAAK,MAAP,CAAA,IAAsB,CAAE,CAAA,GAAI,CAAN,CAAtC;AAAA,mBAAO,MAAP;;AACA,iBAAO;QALT;MAF0B;;MAU5B,GAAK,CAAE,CAAF,EAAK,CAAL,CAAA;AACP,YAAA,QAAA,EAAA,EAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,EAAA,GAAA,EAAA,OAAA,EAAA;QAAI,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,CAApB;UACA,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,GAAhB,CAAoB,CAApB,EAFF;;QAGA,QAAA,GAAY,CAAC,CAAC;QACd,QAAA,GAAY,CAAC,CAAC;QACd,OAAA,GAAY,CAAE,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,QAAnB,CAAF,CAAA,GAAkC;QAC9C,KAAW,wFAAX;UACE,EAAA,GAAK,CAAC,CAAE,GAAF;UACN,EAAA,GAAK,CAAC,CAAE,GAAF;UACN,IAAa,EAAA,GAAK,EAAlB;AAAA,mBAAO,CAAC,EAAR;;UACA,IAAa,EAAA,GAAK,EAAlB;AAAA,mBAAO,CAAC,EAAR;;QAJF;QAKA,IAAa,QAAA,KAAY,QAAzB;AAAA,iBAAQ,EAAR;;QACA,IAAG,QAAA,GAAW,QAAd;UACE,IAAa,IAAC,CAAA,0BAAD,CAA4B,CAA5B,EAA+B,OAAA,GAAU,CAAzC,CAAb;AAAA,mBAAO,CAAC,EAAR;;AACA,iBAAO,CAAC,EAFV;;QAGA,IAAa,IAAC,CAAA,0BAAD,CAA4B,CAA5B,EAA+B,OAAA,GAAU,CAAzC,CAAb;AAAA,iBAAO,CAAC,EAAR;;AACA,eAAO,CAAC;MAjBL;;MAoBL,IAAM,CAAE,IAAF,CAAA,EAAA;;QAEJ,IAAG,IAAC,CAAA,GAAG,CAAC,QAAR;UACE,IAAC,CAAA,KAAK,CAAC,QAAQ,CAAC,IAAhB,CAAqB,IAArB,EADF;;AAEA,eAAO,CAAE,GAAA,IAAF,CAAY,CAAC,IAAb,CAAkB,IAAC,CAAA,GAAnB;MAJH;;IAjGR;;;IAGE,SAAC,CAAA,CAAD,GAAI;;;;gBAjEN;;;EAuKA,IAAC,CAAA,SAAD,GAAc,MAAA,CAAO,IAAC,CAAA,SAAR;;EACd,IAAC,CAAA,SAAD,GAAc,IAAI,IAAC,CAAA,SAAL,CAAA;AAxKd",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'HOLLERITH'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n{ jr\n  assign }                = CND\n{ lets\n  freeze }                = require 'letsfreezethat'\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nC = freeze\n  sign_delta:   0x80000000  ### used to lift negative numbers to non-negative ###\n  u32_width:    4           ### bytes per element ###\n  nr_min:       -0x80000000 ### smallest possible VNR element ###\n  nr_max:       +0x7fffffff ### largest possible VNR element ###\n  #.........................................................................................................\n  defaults:\n    hlr_constructor_cfg:\n      vnr_width:    5           ### maximum elements in VNR vector ###\n      validate:     true\n      # autoextend: false\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\ncreate_types = ( instance ) ->\n  types = new ( require 'intertype' ).Intertype()\n\n  #-----------------------------------------------------------------------------------------------------------\n  types.declare 'hlr_constructor_cfg', tests:\n    \"x is a object\":                    ( x ) -> @isa.object x\n    \"@isa.cardinal x.vnr_width\":        ( x ) -> @isa.cardinal x.vnr_width\n    \"@isa.boolean x.validate\":          ( x ) -> @isa.boolean x.validate\n  types.validate.hlr_constructor_cfg instance.cfg\n\n  #-----------------------------------------------------------------------------------------------------------\n  types.declare 'hlr_vnr', ( x ) ->\n    ### TAINT check bounds of elements ###\n    return false unless @isa.nonempty_list x\n    return x.every ( xx ) => @isa.positive_integer xx\n\n  #-----------------------------------------------------------------------------------------------------------\n  return types\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n### TAINT use separate class? for validation to eschew extra call on each use ###\nclass @Hollerith\n\n  #---------------------------------------------------------------------------------------------------------\n  @C: C\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    @cfg    = { C.defaults.hlr_constructor_cfg..., cfg..., }\n    @types  = create_types @\n    @cfg    = freeze @cfg\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  encode: ( vnr ) ->\n    unless 0 < vnr.length <= @cfg.vnr_width\n      throw new Error \"^44798^ expected VNR to be between 1 and #{@cfg.vnr_width} elements long, got length #{vnr.length}\"\n    R       = Buffer.alloc @cfg.vnr_width * C.u32_width, 0x00 ### TAINT pre-compute constant ###\n    offset  = -C.u32_width\n    for idx in [ 0 ... @cfg.vnr_width ]\n      R.writeUInt32BE ( vnr[ idx ] ? 0 ) + C.sign_delta, ( offset += C.u32_width )\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _encode_bcd: ( vnr ) ->\n    dpe         = 4           ### digits per element ###\n    base        = 36\n    plus        = '+'\n    minus       = '!'\n    padder      = '.'\n    R           = []\n    for idx in [ 0 ... @cfg.vnr_width ]\n      nr    = vnr[ idx ] ? 0\n      sign  = if nr >= 0 then plus else minus\n      R.push sign + ( ( Math.abs nr ).toString base ).padStart dpe, padder\n    return R.join ','\n\n  #---------------------------------------------------------------------------------------------------------\n  create: ( source = null ) =>\n    return [ 0, ] unless source?\n    @types.validate.vnr source if @cfg.validate\n    return [ source..., ]\n\n  #---------------------------------------------------------------------------------------------------------\n  deepen: ( d, nr = 0 ) =>\n    ### Given a vectorial line number `vnr`, return a copy of `vnr`, call it\n    `vnr0`, which has an index of `0` appended, thus representing the pre-first `vnr` for a level of lines\n    derived from the one that the original `vnr` pointed to. ###\n    @types.validate.vnr d if @cfg.validate\n    return [ d..., nr, ]\n\n  #---------------------------------------------------------------------------------------------------------\n  advance:  ( d ) => @move d, +1\n  recede:   ( d ) => @move d, -1\n\n  #---------------------------------------------------------------------------------------------------------\n  move: ( d, delta ) =>\n    ### Given a vectorial line number `vnr`, return a copy of `vnr`, call it\n    `vnr0`, which has its last index incremented by `1`, thus representing the vectorial line number of the\n    next line in the same level that is derived from the same line as its predecessor. ###\n    if @cfg.validate\n      @types.validate.vnr d\n      @types.validate.integer delta\n    R                   = [ d..., ]\n    R[ d.length - 1 ]  += delta\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _first_nonzero_is_negative: ( list, first_idx ) =>\n    idx = first_idx\n    loop\n      if ( R = list[ idx ] ) is 0\n        idx++\n        continue\n      return false if ( R is undefined ) or ( R > 0 )\n      return true\n\n  #---------------------------------------------------------------------------------------------------------\n  cmp: ( a, b ) =>\n    if @cfg.validate\n      @types.validate.vnr a\n      @types.validate.vnr b\n    a_length  = a.length\n    b_length  = b.length\n    min_idx   = ( Math.min a_length, b_length ) - 1\n    for idx in [ 0 .. min_idx ]\n      ai = a[ idx ]\n      bi = b[ idx ]\n      return -1 if ai < bi\n      return +1 if ai > bi\n    return  0 if a_length is b_length\n    if a_length < b_length\n      return +1 if @_first_nonzero_is_negative b, min_idx + 1\n      return -1\n    return -1 if @_first_nonzero_is_negative a, min_idx + 1\n    return +1\n\n  #---------------------------------------------------------------------------------------------------------\n  sort: ( vnrs ) =>\n    ### Given a list of VNRs, return a copy of the list with the VNRs lexicographically sorted. ###\n    if @cfg.validate\n      @types.validate.list vnrs\n    return [ vnrs..., ].sort @cmp\n\n\n#===========================================================================================================\n@Hollerith  = freeze @Hollerith\n@HOLLERITH  = new @Hollerith()\n\n\n"
  ]
}